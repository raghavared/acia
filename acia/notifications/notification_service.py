"""
Notification Service - Sends notifications via email, Slack, webhooks.

This module handles all outbound notifications including:
- Email notifications for PR creation
- Slack alerts for errors
- Webhook integrations
"""

from __future__ import annotations

import asyncio
from abc import ABC, abstractmethod
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from typing import Any

import structlog

from acia.core.config import (
    EmailConfig,
    NotificationsConfig,
    SlackConfig,
    WebhookConfig,
)
from acia.core.models import CycleResult, NotificationEvent, PullRequest, Severity


logger = structlog.get_logger(__name__)


# =============================================================================
# EMAIL TEMPLATES
# =============================================================================

PR_CREATED_TEMPLATE = """
<html>
<body>
<h2>ü§ñ ACIA Created a New Pull Request</h2>

<p><strong>Title:</strong> {title}</p>
<p><strong>PR URL:</strong> <a href="{pr_url}">{pr_url}</a></p>
<p><strong>Branch:</strong> {branch_name}</p>

<h3>Description</h3>
<p>{description}</p>

<h3>Files Changed</h3>
<ul>
{files_list}
</ul>

<hr>
<p style="color: #666; font-size: 12px;">
This PR was automatically generated by ACIA (Autonomous Code Improvement Agent).
Please review before merging.
</p>
</body>
</html>
"""

ERROR_DETECTED_TEMPLATE = """
<html>
<body>
<h2>‚ö†Ô∏è ACIA Detected an Issue</h2>

<p><strong>Severity:</strong> {severity}</p>
<p><strong>Type:</strong> {event_type}</p>

<h3>Details</h3>
<p>{message}</p>

<hr>
<p style="color: #666; font-size: 12px;">
Detected by ACIA (Autonomous Code Improvement Agent).
</p>
</body>
</html>
"""

DAILY_SUMMARY_TEMPLATE = """
<html>
<body>
<h2>üìä ACIA Daily Summary</h2>

<h3>Activity Summary</h3>
<ul>
<li><strong>Cycles Completed:</strong> {cycles}</li>
<li><strong>PRs Created:</strong> {prs_created}</li>
<li><strong>Issues Fixed:</strong> {issues_fixed}</li>
<li><strong>Logs Analyzed:</strong> {logs_analyzed}</li>
<li><strong>Files Analyzed:</strong> {files_analyzed}</li>
</ul>

<h3>PRs Created Today</h3>
{prs_list}

<hr>
<p style="color: #666; font-size: 12px;">
Generated by ACIA (Autonomous Code Improvement Agent).
</p>
</body>
</html>
"""


# =============================================================================
# NOTIFIERS
# =============================================================================

class Notifier(ABC):
    """Base class for notification channels."""
    
    @abstractmethod
    async def send(self, event: NotificationEvent) -> bool:
        """Send a notification."""
        pass


class EmailNotifier(Notifier):
    """Email notification channel."""
    
    def __init__(self, config: EmailConfig):
        self.config = config
        self.smtp = config.smtp
    
    async def send(self, event: NotificationEvent) -> bool:
        """Send an email notification."""
        if not self.config.enabled or not self.smtp:
            return False
        
        recipients = self.config.recipients.get(event.event_type, [])
        if not recipients:
            logger.debug(f"No recipients for event type: {event.event_type}")
            return False
        
        try:
            import aiosmtplib
            
            # Create message
            msg = MIMEMultipart('alternative')
            msg['Subject'] = f"[ACIA] {event.title}"
            msg['From'] = self.config.from_address
            msg['To'] = ', '.join(recipients)
            
            # Create HTML body
            html_body = self._format_html(event)
            msg.attach(MIMEText(html_body, 'html'))
            
            # Get credentials
            username, password = self.smtp.get_credentials()
            
            # Send
            await aiosmtplib.send(
                msg,
                hostname=self.smtp.host,
                port=self.smtp.port,
                start_tls=self.smtp.use_tls,
                username=username,
                password=password,
            )
            
            logger.info(
                "Email sent",
                event_type=event.event_type,
                recipients=recipients,
            )
            return True
        
        except Exception as e:
            logger.error(f"Failed to send email: {e}")
            return False
    
    def _format_html(self, event: NotificationEvent) -> str:
        """Format HTML body based on event type."""
        if event.event_type == "pr_created":
            return PR_CREATED_TEMPLATE.format(
                title=event.title,
                pr_url=event.message,  # Assuming message contains URL
                branch_name="",
                description=event.message,
                files_list="<li>See PR for details</li>",
            )
        elif event.event_type in ("error_detected", "security_issue"):
            return ERROR_DETECTED_TEMPLATE.format(
                severity=event.severity.value,
                event_type=event.event_type,
                message=event.message,
            )
        else:
            return f"<p>{event.message}</p>"


class SlackNotifier(Notifier):
    """Slack notification channel."""
    
    def __init__(self, config: SlackConfig):
        self.config = config
    
    async def send(self, event: NotificationEvent) -> bool:
        """Send a Slack notification."""
        if not self.config.enabled:
            return False
        
        webhook_url = self.config.get_webhook_url()
        if not webhook_url:
            return False
        
        try:
            import httpx
            
            # Build Slack message
            color = self._severity_to_color(event.severity)
            
            payload = {
                "channel": self.config.channel,
                "attachments": [{
                    "color": color,
                    "title": event.title,
                    "text": event.message,
                    "footer": "ACIA Bot",
                    "ts": int(event.timestamp.timestamp()),
                }]
            }
            
            async with httpx.AsyncClient() as client:
                response = await client.post(webhook_url, json=payload)
                response.raise_for_status()
            
            logger.info(f"Slack notification sent: {event.event_type}")
            return True
        
        except Exception as e:
            logger.error(f"Failed to send Slack notification: {e}")
            return False
    
    def _severity_to_color(self, severity: Severity) -> str:
        """Map severity to Slack attachment color."""
        colors = {
            Severity.LOW: "#36a64f",      # Green
            Severity.MEDIUM: "#ffcc00",    # Yellow
            Severity.HIGH: "#ff9900",      # Orange
            Severity.CRITICAL: "#ff0000",  # Red
        }
        return colors.get(severity, "#808080")


class WebhookNotifier(Notifier):
    """Generic webhook notification channel."""
    
    def __init__(self, config: WebhookConfig):
        self.config = config
    
    async def send(self, event: NotificationEvent) -> bool:
        """Send webhook notifications."""
        if not self.config.enabled:
            return False
        
        success = True
        
        for endpoint in self.config.endpoints:
            if event.event_type in endpoint.events:
                try:
                    import httpx
                    import os
                    
                    headers = {}
                    if endpoint.auth_header_env_var:
                        auth_value = os.getenv(endpoint.auth_header_env_var)
                        if auth_value:
                            headers["Authorization"] = auth_value
                    
                    payload = {
                        "id": event.id,
                        "timestamp": event.timestamp.isoformat(),
                        "event_type": event.event_type,
                        "title": event.title,
                        "message": event.message,
                        "severity": event.severity.value,
                    }
                    
                    async with httpx.AsyncClient() as client:
                        response = await client.post(
                            endpoint.url,
                            json=payload,
                            headers=headers,
                            timeout=30.0,
                        )
                        response.raise_for_status()
                    
                    logger.info(f"Webhook sent to {endpoint.url}")
                
                except Exception as e:
                    logger.error(f"Webhook to {endpoint.url} failed: {e}")
                    success = False
        
        return success


# =============================================================================
# NOTIFICATION SERVICE
# =============================================================================

class NotificationService:
    """
    Main notification service that coordinates all notification channels.
    """
    
    def __init__(self, config: NotificationsConfig):
        self.config = config
        self.notifiers: list[Notifier] = []
        self._initialized = False
    
    async def initialize(self) -> None:
        """Initialize notification channels."""
        if self._initialized:
            return
        
        if self.config.email.enabled:
            self.notifiers.append(EmailNotifier(self.config.email))
        
        if self.config.slack.enabled:
            self.notifiers.append(SlackNotifier(self.config.slack))
        
        if self.config.webhook.enabled:
            self.notifiers.append(WebhookNotifier(self.config.webhook))
        
        self._initialized = True
        logger.info(f"Initialized {len(self.notifiers)} notification channels")
    
    async def notify(self, event: NotificationEvent) -> int:
        """
        Send a notification through all channels.
        
        Returns the number of successful notifications.
        """
        await self.initialize()
        
        tasks = [notifier.send(event) for notifier in self.notifiers]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        success_count = sum(1 for r in results if r is True)
        
        event.email_sent = any(
            isinstance(n, EmailNotifier) and r is True
            for n, r in zip(self.notifiers, results)
        )
        event.slack_sent = any(
            isinstance(n, SlackNotifier) and r is True
            for n, r in zip(self.notifiers, results)
        )
        event.webhook_sent = any(
            isinstance(n, WebhookNotifier) and r is True
            for n, r in zip(self.notifiers, results)
        )
        
        return success_count
    
    async def notify_pr_created(self, pr: PullRequest) -> int:
        """Send notification for PR creation."""
        event = NotificationEvent(
            event_type="pr_created",
            title=pr.title,
            message=f"PR #{pr.pr_number}: {pr.pr_url}\n\n{pr.description}",
            severity=Severity.LOW,
            pull_request_id=pr.id,
        )
        return await self.notify(event)
    
    async def notify_error(self, error: str, cycle_id: str | None = None) -> int:
        """Send notification for an error."""
        event = NotificationEvent(
            event_type="error_detected",
            title="ACIA Error",
            message=error,
            severity=Severity.HIGH,
        )
        return await self.notify(event)
    
    async def notify_security_issue(
        self,
        title: str,
        description: str,
        severity: Severity,
    ) -> int:
        """Send notification for security issue."""
        event = NotificationEvent(
            event_type="security_issue",
            title=title,
            message=description,
            severity=severity,
        )
        return await self.notify(event)
    
    async def notify_cycle_complete(self, cycle: CycleResult) -> int:
        """Send notifications for completed cycle."""
        total_sent = 0
        
        # Notify for each PR created
        for pr in cycle.pull_requests:
            sent = await self.notify_pr_created(pr)
            total_sent += sent
        
        # Notify for critical issues
        if cycle.code_analysis:
            critical_issues = cycle.code_analysis.issues_by_severity.get("critical", 0)
            high_issues = cycle.code_analysis.issues_by_severity.get("high", 0)
            
            if critical_issues > 0:
                event = NotificationEvent(
                    event_type="error_detected",
                    title=f"Found {critical_issues} critical issues",
                    message=f"Critical: {critical_issues}, High: {high_issues}",
                    severity=Severity.CRITICAL,
                )
                total_sent += await self.notify(event)
        
        return total_sent
    
    async def send_daily_summary(
        self,
        cycles: int,
        prs_created: int,
        issues_fixed: int,
        logs_analyzed: int,
        files_analyzed: int,
        pr_list: list[dict],
    ) -> int:
        """Send daily summary email."""
        prs_html = ""
        if pr_list:
            for pr in pr_list:
                prs_html += f"<li><a href='{pr['url']}'>{pr['title']}</a></li>"
        else:
            prs_html = "<li>No PRs created today</li>"
        
        message = DAILY_SUMMARY_TEMPLATE.format(
            cycles=cycles,
            prs_created=prs_created,
            issues_fixed=issues_fixed,
            logs_analyzed=logs_analyzed,
            files_analyzed=files_analyzed,
            prs_list=f"<ul>{prs_html}</ul>",
        )
        
        event = NotificationEvent(
            event_type="daily_summary",
            title="ACIA Daily Summary",
            message=message,
            severity=Severity.LOW,
        )
        
        return await self.notify(event)
